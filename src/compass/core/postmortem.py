"""Post-mortem generation for completed investigations.

This module provides functionality to generate markdown-formatted post-mortem
documents from completed OODA investigations, capturing results for learning,
communication, and compliance.
"""

from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional

from compass.core.investigation import Investigation
from compass.core.ooda_orchestrator import OODAResult
from compass.core.phases.act import ValidationResult
from compass.core.scientific_framework import Hypothesis


@dataclass
class PostMortem:
    """Post-mortem document for completed investigation.

    Captures investigation results in standardized format for
    learning, communication, and compliance.
    """

    # Core identification
    investigation_id: str
    generated_at: datetime

    # Incident details
    service: str
    symptom: str
    severity: str

    # Investigation results
    status: str  # "RESOLVED", "INCONCLUSIVE", etc.
    selected_hypothesis: Optional[Hypothesis]
    validation_result: Optional[ValidationResult]

    # Metadata
    total_cost: float
    duration_seconds: float
    agent_count: int

    def to_markdown(self) -> str:
        """Render post-mortem as markdown document.

        Handles both RESOLVED (with hypothesis) and INCONCLUSIVE (no hypothesis) cases.

        Returns:
            Markdown-formatted post-mortem document
        """
        # Format timestamp
        timestamp = self.generated_at.strftime("%Y-%m-%d %H:%M:%S UTC")

        # Header
        md = f"# Post-Mortem: {self.service} - {self.symptom}\n\n"
        md += f"**Generated:** {timestamp}\n"
        md += f"**Investigation ID:** {self.investigation_id}\n"
        md += f"**Severity:** {self.severity}\n"
        md += f"**Status:** {self.status.upper()}\n\n"
        md += "---\n\n"

        # Summary
        md += "## Summary\n\n"
        md += f"**Service:** {self.service}\n"
        md += f"**Symptom:** {self.symptom}\n"
        md += f"**Duration:** {self.duration_seconds:.1f} seconds\n"
        md += f"**Cost:** ${self.total_cost:.4f}\n"
        md += f"**Agents:** {self.agent_count} specialist agent(s)\n\n"
        md += "---\n\n"

        # Contributing Factors (Learning Teams methodology - no blame language)
        md += "## Contributing Factors\n\n"
        if self.selected_hypothesis and self.validation_result:
            md += f"**Primary Hypothesis:** {self.selected_hypothesis.statement}\n"
            md += f"**Confidence:** {self.validation_result.updated_confidence:.0%} "
            md += f"(initial: {self.selected_hypothesis.initial_confidence:.0%})\n"
            md += f"**Source:** {self.selected_hypothesis.agent_id}\n\n"
            md += "**Reasoning:**\n"
            md += f"{self.selected_hypothesis.confidence_reasoning}\n\n"
        else:
            md += "**Status:** INCONCLUSIVE - No hypotheses could be validated\n\n"
            md += "The investigation did not identify contributing factors with sufficient confidence. "
            md += "This may indicate:\n"
            md += "- Insufficient observability data available\n"
            md += "- Symptoms resolved before investigation completed\n"
            md += "- Contributing factors require additional specialist agents\n\n"

        md += "---\n\n"

        # Validation (only if hypothesis was validated)
        if self.validation_result:
            md += "## Validation\n\n"
            md += "**Disproof Strategies Applied:**\n"
            for attempt in self.validation_result.attempts:
                md += f"- âœ“ {attempt.strategy}: Not disproven\n"
            md += f"\n**Final Confidence:** {self.validation_result.updated_confidence:.0%}\n\n"
            md += "---\n\n"

        # Recommendations (only if we have a hypothesis with affected systems)
        if self.selected_hypothesis and self.selected_hypothesis.affected_systems:
            md += "## Recommendations\n\n"
            md += "Based on validated hypothesis and affected systems:\n"
            for system in self.selected_hypothesis.affected_systems:
                md += f"- Review and remediate {system}\n"
            md += "\n---\n\n"

        # Footer
        md += "*Generated by COMPASS on " + timestamp + "*\n"

        return md

    @classmethod
    def from_ooda_result(cls, result: OODAResult) -> "PostMortem":
        """Create post-mortem from OODA investigation result.

        Args:
            result: Completed OODA investigation result

        Returns:
            PostMortem instance
        """
        investigation = result.investigation

        # Extract selected hypothesis (if any)
        selected_hypothesis = None
        if result.validation_result:
            selected_hypothesis = result.validation_result.hypothesis

        # Calculate duration using updated_at (not completed_at which doesn't exist)
        if investigation.updated_at and investigation.created_at:
            duration = (investigation.updated_at - investigation.created_at).total_seconds()
        else:
            duration = 0.0

        # Calculate unique agent count from observations
        # Each observation dict has 'agent_id' key
        unique_agents = set(
            obs.get('agent_id')
            for obs in investigation.observations
            if isinstance(obs, dict) and 'agent_id' in obs
        )
        agent_count = len(unique_agents) if unique_agents else 0

        return cls(
            # Use investigation.id not investigation.investigation_id
            investigation_id=str(investigation.id),
            generated_at=datetime.now(timezone.utc),
            # Access service/symptom/severity via context, not direct attributes
            service=investigation.context.service,
            symptom=investigation.context.symptom,
            severity=investigation.context.severity,
            status=investigation.status.value,
            selected_hypothesis=selected_hypothesis,
            validation_result=result.validation_result,
            total_cost=investigation.total_cost,
            duration_seconds=duration,
            agent_count=agent_count,
        )


def save_postmortem(postmortem: PostMortem, output_dir: str = "postmortems") -> str:
    """Save post-mortem to markdown file.

    Uses pathlib.Path for type-safe file operations (mypy --strict compliant).
    Includes investigation ID in filename to prevent collisions.

    Args:
        postmortem: Post-mortem document to save
        output_dir: Directory to save post-mortem (default: "postmortems")

    Returns:
        Absolute path to saved post-mortem file (as string)

    Raises:
        IOError: If file cannot be written (permissions, disk full, etc.)
    """
    # Convert to Path for type safety
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    # Sanitize service name for filename (replace invalid characters)
    safe_service = "".join(
        c if c.isalnum() or c in ('-', '_') else '_'
        for c in postmortem.service
    )

    # Generate filename with investigation ID for uniqueness
    timestamp = postmortem.generated_at.strftime("%Y-%m-%d-%H%M%S")
    short_id = postmortem.investigation_id[:8]  # First 8 chars of UUID
    filename = f"{safe_service}-{short_id}-{timestamp}.md"
    filepath = output_path / filename

    # Write file with explicit encoding
    try:
        filepath.write_text(postmortem.to_markdown(), encoding="utf-8")
    except OSError as e:
        raise IOError(
            f"Failed to write post-mortem to {filepath}: {e}"
        ) from e

    return str(filepath.absolute())
